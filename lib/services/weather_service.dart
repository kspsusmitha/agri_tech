import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import '../models/weather_model.dart';
import '../models/notification_model.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:firebase_vertexai/firebase_vertexai.dart';
import 'notification_service.dart';

class WeatherService {
  // OpenMeteo is free and doesn't require an API key
  static const String _baseUrl = 'https://api.open-meteo.com/v1';

  final DatabaseReference _database = FirebaseDatabase.instance.ref();
  final NotificationService _notificationService = NotificationService();

  // Initialize Vertex AI
  // Note: Ensure Vertex AI API is enabled in Firebase Console
  late final GenerativeModel _model;

  WeatherService() {
    _model = FirebaseVertexAI.instance.generativeModel(
      model: 'gemini-2.0-flash',
    );
  }

  /// Fetch current weather for a location and generate AI insights
  Future<WeatherModel> getCurrentWeather(
    String farmerId, {
    double? lat,
    double? lon,
  }) async {
    try {
      if (lat == null || lon == null) {
        // Default to a known location (e.g., San Francisco) if no location provided
        // or return mock if specifically testing without location
        return _getMockWeather(farmerId);
      }

      // Fetch from OpenMeteo
      // https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m
      final url =
          '$_baseUrl/forecast?latitude=$lat&longitude=$lon&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m&wind_speed_unit=kmh';

      final response = await http.get(Uri.parse(url));

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final current = data['current'];

        // Map WMO weather code to condition string
        final condition = _getConditionFromCode(current['weather_code']);

        // Create base weather model
        var weather = WeatherModel(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          farmerId: farmerId,
          temperature: (current['temperature_2m'] as num).toDouble(),
          humidity: (current['relative_humidity_2m'] as num).toDouble(),
          condition: condition,
          alertType: null, // Will be determined by AI or logic
          alertMessage: null, // Will be generated by AI
          timestamp: DateTime.now(),
        );

        // Generate AI Insight
        try {
          final aiInsight = await _generateAIInsight(weather);
          weather = WeatherModel(
            id: weather.id,
            farmerId: weather.farmerId,
            temperature: weather.temperature,
            humidity: weather.humidity,
            condition: weather.condition,
            alertType:
                aiInsight['type'], // e.g., 'advisory', 'warning', 'critical'
            alertMessage: aiInsight['message'],
            timestamp: weather.timestamp,
          );

          // Check if notification is needed
          await _checkAndSendNotification(weather);
        } catch (e) {
          debugPrint('⚠️ [Weather Service] AI Generation failed: $e');
          // Fallback to basic logic if AI fails
          weather = WeatherModel(
            id: weather.id,
            farmerId: weather.farmerId,
            temperature: weather.temperature,
            humidity: weather.humidity,
            condition: weather.condition,
            alertType: _determineBasicAlertType(weather),
            alertMessage: _determineBasicAlertMessage(weather),
            timestamp: weather.timestamp,
          );
        }

        // Save to RTDB for history
        await _saveWeatherHistory(weather);
        return weather;
      } else {
        debugPrint('❌ [Weather Service] API Error: ${response.statusCode}');
        return _getMockWeather(farmerId);
      }
    } catch (e) {
      debugPrint('❌ [Weather Service] Error: $e');
      return _getMockWeather(farmerId);
    }
  }

  Future<void> _checkAndSendNotification(WeatherModel weather) async {
    final type = weather.alertType?.toLowerCase() ?? '';
    // Send notification only for significant alerts
    if (type.contains('warning') ||
        type.contains('critical') ||
        type.contains('storm') ||
        type.contains('heat')) {
      final notification = NotificationModel(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        userId: weather.farmerId,
        title: 'Weather Alert: ${weather.alertType?.toUpperCase()}',
        message: weather.alertMessage ?? 'Severe weather conditions detected.',
        type: 'weather',
        timestamp: DateTime.now(),
        isRead: false,
        relatedId: weather.id,
      );

      try {
        await _notificationService.sendNotification(notification);
      } catch (e) {
        debugPrint('Failed to send weather notification: $e');
      }
    }
  }

  Future<Map<String, String>> _generateAIInsight(WeatherModel weather) async {
    final prompt =
        '''
      Act as an agricultural expert. Analyze these weather conditions for a general crop farm:
      - Temperature: ${weather.temperature}°C
      - Humidity: ${weather.humidity}%
      - Condition: ${weather.condition}
      
      Provide a concise 1-sentence farming advice or alert.
      Also categorize the alert level as one of: 'safe', 'advisory', 'warning', 'critical'.
      
      Output strictly in JSON format: {"type": "category", "message": "advice"}
    ''';

    final content = [Content.text(prompt)];
    final response = await _model.generateContent(content);

    final responseText = response.text;
    if (responseText != null) {
      // Remove any markdown code block formatting if present
      final jsonString = responseText
          .replaceAll('```json', '')
          .replaceAll('```', '')
          .trim();
      final data = json.decode(jsonString);
      return {
        'type': data['type']?.toString().toLowerCase() ?? 'advisory',
        'message': data['message']?.toString() ?? 'Monitor crop conditions.',
      };
    }
    return {
      'type': 'advisory',
      'message': 'No specific advice available at this time.',
    };
  }

  String _getConditionFromCode(int code) {
    // WMO Weather interpretation codes (https://open-meteo.com/en/docs)
    if (code == 0) return 'Clear Sky';
    if (code <= 3) return 'Partly Cloudy';
    if (code <= 48) return 'Foggy';
    if (code <= 55) return 'Drizzle';
    if (code <= 65) return 'Rain';
    if (code <= 75) return 'Snow';
    if (code <= 82) return 'Rain Showers';
    if (code <= 86) return 'Snow Showers';
    if (code <= 99) return 'Thunderstorm';
    return 'Unknown';
  }

  WeatherModel _getMockWeather(String farmerId) {
    return WeatherModel(
      id: 'mock_${DateTime.now().millisecondsSinceEpoch}',
      farmerId: farmerId,
      temperature: 28.5,
      humidity: 65,
      condition: 'Cloudy',
      alertType: 'rainfall',
      alertMessage:
          'Expected heavy rainfall in the next 3 hours. Plan your irrigation accordingly.',
      timestamp: DateTime.now(),
    );
  }

  String? _determineBasicAlertType(WeatherModel w) {
    if (w.humidity > 80 && w.temperature > 30) return 'heat';
    if (w.condition.toLowerCase().contains('rain')) return 'rainfall';
    if (w.condition.toLowerCase().contains('storm')) return 'storm';
    return null;
  }

  String? _determineBasicAlertMessage(WeatherModel w) {
    if (w.humidity > 80 && w.temperature > 30) {
      return 'High heat and humidity - risk of fungal diseases.';
    }
    if (w.condition.toLowerCase().contains('rain')) {
      return 'Rain expected - pause irrigation.';
    }
    return null;
  }

  Future<void> _saveWeatherHistory(WeatherModel weather) async {
    await _database
        .child('weather_history')
        .child(weather.farmerId)
        .child(weather.id)
        .set(weather.toJson());
  }

  /// Get weather alert history for a farmer
  Stream<List<WeatherModel>> getWeatherHistory(String farmerId) {
    return _database.child('weather_history').child(farmerId).onValue.map((
      event,
    ) {
      if (!event.snapshot.exists) return [];
      final data = event.snapshot.value as Map<dynamic, dynamic>;
      return data.values
          .map((v) => WeatherModel.fromJson(Map<String, dynamic>.from(v)))
          .toList()
        ..sort((a, b) => b.timestamp.compareTo(a.timestamp));
    });
  }
}
